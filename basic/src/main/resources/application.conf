logging {
  level = INFO

  # Log dead letters
  dead-letters = on

  # Log all LoggingFSMs for events, transitions and timers (using akka.actor.LoggingFSM[StateType, Data])
  fsm = on

  # Logging of message invocations on certain (local) actors (using akka.event.LoggingReceive)
  receive = on

  # Log unhandled actor messages
  unhandled = on

  # Log cluster informational messages
  cluster = on

  # Log all inbound and outbound messages to remote actors
  remote = off
}

akka {
  loglevel = ${logging.level}
  log-dead-letters = ${logging.dead-letters}
  extensions = ["com.romix.akka.serialization.kryo.KryoSerializationExtension"]

  persistence {
    journal.plugin = "cassandra-journal"
    snapshot-store.plugin = "cassandra-snapshot-store"
  }

  actor {

    serialization-bindings {
      "io.muvr.exercise.ExercisePlanDeviation" = kryo,
      "io.muvr.exercise.ResistanceExercise" = kryo,
      "io.muvr.exercise.ResistanceExerciseSet" = kryo,
      "io.muvr.exercise.ResistanceExerciseSetExample" = kryo,
      "io.muvr.exercise.EntireResistanceExerciseSession" = kryo,
      "io.muvr.exercise.ResistanceExerciseSession" = kryo,
      "io.muvr.exercise.Rest" = kryo,
      "io.muvr.exercise.SessionId" = kryo
    }

    serializers {
      java = "akka.serialization.JavaSerializer"
      kryo = "com.romix.akka.serialization.kryo.KryoSerializer"
    }

    kryo  {
      # Possibles values for type are: graph or nograph
      # graph supports serialization of object graphs with shared nodes
      # and cyclic references, but this comes at the expense of a small overhead
      # nograph does not support object grpahs with shared nodes, but is usually faster
      type = "graph"

      # Possible values for idstrategy are:
      # default, explicit, incremental
      #
      # default - slowest and produces bigger serialized representation. Contains fully-
      # qualified class names (FQCNs) for each class. Note that selecting this strategy
      # does not work in version 0.3.2, but is available on master and from 0.3.3 onward.
      #
      # explicit - fast and produces compact serialized representation. Requires that all
      # classes that will be serialized are pre-registered using the "mappings" and "classes"
      # sections. To guarantee that both sender and receiver use the same numeric ids for the same
      # classes it is advised to provide exactly the same entries in the "mappings" section
      #
      # incremental - fast and produces compact serialized representation. Support optional
      # pre-registering of classes using the "mappings" and "classes" sections. If class is
      # not pre-registered, it will be registered dynamically by picking a next available id
      # To guarantee that both sender and receiver use the same numeric ids for the same
      # classes it is advised to pre-register them using at least the "classes" section
      idstrategy = "incremental"

      # Define a default size for serializer pool
      # Try to define the size to be at least as big as the max possible number
      # of threads that may be used for serialization, i.e. max number
      # of threads allowed for the scheduler
      serializer-pool-size = 16

      # Define a default size for byte buffers used during serialization
      buffer-size = 4096

      # The serialization byte buffers are doubled as needed until they exceed max-buffer-size and an exception is thrown. Can be -1 for no maximum.
      max-buffer-size = -1

      # If set, akka uses manifests to put a class name
      # of the top-level object into each message
      use-manifests = false

      # The transformations that have be done while serialization
      # Supported transformations: compression and encryption
      # accepted values(comma separated if multiple): off | lz4 | deflate | aes
      # Transformations occur in the order they are specified
      post-serialization-transformations = "lz4"

      # Settings for aes encryption, if included in transformations
      # AES algo mode, key and custom key class can be specified
      # AES algo mode defaults to 'AES/CBC/PKCS5Padding' and key to 'ThisIsASecretKey'
      # If custom key class is provided, Kryo uses the class specified by a fully qualified class name
      # to get custom AES key. Such a class should define the method 'kryoAESKey'.
      # This key overrides 'key'. If class doesn't contain 'kryoAESKey' method,
      # specified key is used. If this is not present, default key is used

      #encryption {
      #  aes {
      #    mode = "AES/CBC/PKCS5Padding"
      #    key = j68KkRjq21ykRGAQ
      #    custom-key-class = "CustomAESKeyClass"
      #  }
      #}

      # Log implicitly registered classes. Useful, if you want to know all classes
      # which are serialized. You can then use this information in the mappings and/or
      # classes sections
      implicit-registration-logging = false

      # If enabled, Kryo logs a lot of information about serialization process.
      # Useful for debugging and lowl-level tweaking
      kryo-trace = false

      # If proviced, Kryo uses the class specified by a fully qualified class name
      # to perform a custom initialization of Kryo instances in addition to what
      # is done automatically based on the config file.
      #kryo-custom-serializer-init = "CustomKryoSerializerInitFQCN"

      # Define mappings from a fully qualified class name to a numeric id.
      # Smaller ids lead to smaller sizes of serialized representations.
      #
      # This section is mandatory for idstartegy=explicit
      # This section is optional  for idstartegy=incremental
      # This section is ignored   for idstartegy=default
      #
      # The smallest possible id should start at 20 (or even higher), because
      # ids below it are used by Kryo internally e.g. for built-in Java and
      # Scala types
      mappings {
        "io.muvr.exercise.ExercisePlanDeviation" = 100,
        "io.muvr.exercise.ResistanceExercise" = 101,
        "io.muvr.exercise.ResistanceExerciseSet" = 102,
        "io.muvr.exercise.ResistanceExerciseSetExample" = 103,
        "io.muvr.exercise.EntireResistanceExerciseSession" = 104,
        "io.muvr.exercise.ResistanceExerciseSession" = 105,
        "io.muvr.exercise.Rest" = 106,
        "io.muvr.exercise.SessionId" = 107
      }

      # Define a set of fully qualified class names for
      # classes to be used for serialization.
      # The ids for those classes will be assigned automatically,
      # but respecting the order of declaration in this section
      #
      # This section is optional  for idstartegy=incremental
      # This section is ignored   for idstartegy=default
      # This section is optional  for idstartegy=explicit
      classes = [
        "io.muvr.exercise.ExercisePlanDeviation",
        "io.muvr.exercise.ResistanceExercise",
        "io.muvr.exercise.ResistanceExerciseSet",
        "io.muvr.exercise.ResistanceExerciseSetExample",
        "io.muvr.exercise.EntireResistanceExerciseSession",
        "io.muvr.exercise.ResistanceExerciseSession",
        "io.muvr.exercise.Rest",
        "io.muvr.exercise.SessionId"
      ]
    }
  }
}

cassandra {
  host = ${?CASSANDRA_HOST}
}

spark {
  master = "spark://"${?SPARK_MASTER_HOST}":"${?SPARK_MASTER_PORT}
}

jobs {
  suggestions {
    historySizeParameter = 5
    futureSizeParameter = 3
    interval = 30m
    includeUsersSessionEndedBefore = 35m
  }
}

app {
  rest {
    api = ${?APP_REST_API}
    port = ${?APP_REST_PORT}
  }
}